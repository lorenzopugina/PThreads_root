void *mergesort(void *args) {

    parametros_mergesort *param = (parametros_mergesort *) args;
    int Indicecomeco = param->Indicecomeco;
    int Indicefinal = param->Indicefinal;
    int *vetor = param->vetor;

    if (Indicecomeco < Indicefinal - 1) {
        int meio = (Indicecomeco + Indicefinal) / 2;

        // Armazena os argumentos de cada metade do vetor
        parametros_mergesort arg1 = {Indicecomeco, meio, vetor};
        parametros_mergesort arg2 = {meio, Indicefinal, vetor};

        // Criação de threads para cada metade
        pthread_t thread1, thread2;

        if (numThread < MAX_THREADS) { // cria threads até o limite definido
            pthread_create(&thread1, NULL, mergesort, &arg1);
            numThread++;
            pthread_join(thread1, NULL); // tira isso dps ----------------------------------------------------------------------------------
        } 
        else {
            mergesort(&arg1); // Se ja estiver no limite, continua com a recursividade
        }

        if (numThread < MAX_THREADS) { // mesma coisa só q pra outra metade
            pthread_create(&thread2, NULL, mergesort, &arg2);
            numThread++;
            pthread_join(thread2, NULL); // tira isso deps ---------------------------------------------------------------------------------
        } 
        else {
            mergesort(&arg2);
        }

        // Espera as threads terminarem

        pthread_join(thread1, NULL);
        pthread_join(thread2, NULL);
        

        // Intercala as duas metades
        intercala(Indicecomeco, meio, Indicefinal, vetor);
    }

    numThread--;
    pthread_exit(NULL);
}