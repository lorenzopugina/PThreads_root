#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>

typedef struct {
    int idThread;
    char* arquivo;
    int* vetor;
    int indiceComeço;
    int indiceFinal;
    int numArg;
} parametrosLeitura;

void* leitura(void* arg) {
    parametrosLeitura* parametros = (parametrosLeitura*)arg;

    FILE* arquivo = fopen(parametros->arquivo, "r"); // Abre o arquivo em modo de leitura texto

    if (arquivo == NULL) {
        printf("Não abriu o arquivo %s\n", parametros->arquivo);
        return NULL;
    }

    // Move o ponteiro do arquivo para a posição correta
    fseek(arquivo, 0, SEEK_SET); // Para garantir que estamos no início do arquivo

    // Leitura dos números
    for (int i = 0; i < parametros->indiceFinal - parametros->indiceComeço + 1; i++) {
        int temp;
        // Lê até 1000 números (ajuste se necessário para seu caso específico)
        if (fscanf(arquivo, "%d", &temp) == 1) {
            parametros->vetor[parametros->indiceComeço + i + (parametros->numArg * 1000)] = temp;
        } else {
            printf("Thread %d Não leu corretamente\n", parametros->idThread);
            break;
        }
    }

    fclose(arquivo);
    free(parametros->arquivo); // Libera memória alocada
    free(parametros); // Libera parâmetros da thread
    pthread_exit(NULL); // Finaliza a thread
}

int main(int argc, char const *argv[]) {
    int numThreads = atoi(argv[1]);
    pthread_t* leitor = (pthread_t*)malloc(numThreads * sizeof(pthread_t));

    int quantidade = (argc - 3) * 1000; 
    int* vetorPrincipal = (int*)malloc(quantidade * sizeof(int));

    for (int j = 2; j < argc - 1; j++) {
        for (int i = 0; i < numThreads; i++) {
            parametrosLeitura* parametros = malloc(sizeof(parametrosLeitura));
            parametros->idThread = i; 
            parametros->arquivo = strdup(argv[j]); 
            parametros->vetor = vetorPrincipal; 

            // Cálculo dos índices
            parametros->indiceComeço = (1000 / numThreads) * i;
            parametros->indiceFinal = (i == numThreads - 1) ? 999 : ((1000 / numThreads) * (i + 1)) - 1; // Última thread lê até o fim

            parametros->numArg = j - 2;
            
            if (pthread_create(&leitor[i], NULL, leitura, (void*)parametros) != 0) {
                printf("Erro ao criar a thread");
                free(parametros->arquivo);
                free(parametros);
                free(vetorPrincipal);
                return 1;
            }
        }

        // Espera as threads terminarem antes de continuar
        for (int i = 0; i < numThreads; i++) {
            pthread_join(leitor[i], NULL);
        }
    }

    // Imprime em um arquivo separado o resultado final
    int quebraLinha = 0;
    FILE* saida = fopen(argv[argc - 1], "w+");
    for (int i = 0; i < quantidade; i++) { 
        quebraLinha++;
        fprintf(saida, "%d ", vetorPrincipal[i]);
        if (quebraLinha == 25) {
            fprintf(saida, "\n");
            quebraLinha = 0;
        }
    }

    fclose(saida);
    free(vetorPrincipal);
    free(leitor); // Libera memória do vetor de threads
    
    return 0;
}
